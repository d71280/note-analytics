<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        .status-box {
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: 500;
        }
        .online {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .offline {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-left: 4px solid #007bff;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover {
            background: #0056b3;
        }
        .log {
            max-height: 300px;
            overflow-y: auto;
            background: #f1f1f1;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            background: white;
            border-radius: 2px;
        }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        .info { color: blue; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h1>
        
        <div id="networkStatus" class="status-box online">
            ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ…‹: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³
        </div>
        
        <div class="test-section">
            <h2>1. Service Worker çŠ¶æ…‹</h2>
            <div id="swStatus" class="test-result">ãƒã‚§ãƒƒã‚¯ä¸­...</div>
            <button onclick="checkServiceWorker()">Service Workerç¢ºèª</button>
            <button onclick="registerServiceWorker()">Service Workerç™»éŒ²</button>
            <button onclick="unregisterServiceWorker()">Service Workerå‰Šé™¤</button>
        </div>
        
        <div class="test-section">
            <h2>2. IndexedDB çŠ¶æ…‹</h2>
            <div id="dbStatus" class="test-result">ãƒã‚§ãƒƒã‚¯ä¸­...</div>
            <button onclick="checkIndexedDB()">IndexedDBç¢ºèª</button>
            <button onclick="addTestData()">ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿è¿½åŠ </button>
            <button onclick="clearIndexedDB()">ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢</button>
        </div>
        
        <div class="test-section">
            <h2>3. ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆ</h2>
            <button onclick="simulateOffline()">ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ</button>
            <button onclick="simulateOnline()">ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã«æˆ»ã™</button>
            <button onclick="testOfflinePost()">ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æŠ•ç¨¿ãƒ†ã‚¹ãƒˆ</button>
            <button onclick="checkOfflineQueue()">ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼ç¢ºèª</button>
        </div>
        
        <div class="test-section">
            <h2>4. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆãƒ†ã‚¹ãƒˆ</h2>
            <button onclick="openApp()">ã‚¢ãƒ—ãƒªã‚’é–‹ã</button>
            <button onclick="checkAppIntegration()">çµ±åˆçŠ¶æ…‹ã‚’ç¢ºèª</button>
        </div>
        
        <div class="test-section">
            <h2>ãƒ­ã‚°</h2>
            <div id="log" class="log"></div>
            <button onclick="clearLog()">ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
        </div>
    </div>

    <script>
        // ãƒ­ã‚°è¨˜éŒ²
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.insertBefore(entry, logDiv.firstChild);
        }

        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ…‹ã®ç›£è¦–
        function updateNetworkStatus() {
            const statusDiv = document.getElementById('networkStatus');
            if (navigator.onLine) {
                statusDiv.className = 'status-box online';
                statusDiv.textContent = 'ğŸŸ¢ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ…‹: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³';
                log('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³', 'success');
            } else {
                statusDiv.className = 'status-box offline';
                statusDiv.textContent = 'ğŸŸ¡ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ…‹: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³';
                log('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³', 'warning');
            }
        }

        window.addEventListener('online', updateNetworkStatus);
        window.addEventListener('offline', updateNetworkStatus);

        // Service Worker ãƒã‚§ãƒƒã‚¯
        async function checkServiceWorker() {
            try {
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    const swDiv = document.getElementById('swStatus');
                    
                    if (registrations.length > 0) {
                        swDiv.innerHTML = 'âœ… Service Workerç™»éŒ²æ¸ˆã¿<br>';
                        registrations.forEach((reg, index) => {
                            swDiv.innerHTML += `SW ${index + 1}: ${reg.scope}<br>`;
                            swDiv.innerHTML += `çŠ¶æ…‹: ${reg.active ? 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ–' : 'ã‚¤ãƒ³ã‚¢ã‚¯ãƒ†ã‚£ãƒ–'}<br>`;
                        });
                        log('Service Workerç¢ºèªå®Œäº†', 'success');
                    } else {
                        swDiv.textContent = 'âŒ Service Workeræœªç™»éŒ²';
                        log('Service Workeræœªç™»éŒ²', 'warning');
                    }
                } else {
                    document.getElementById('swStatus').textContent = 'âŒ Service Workeréå¯¾å¿œ';
                    log('Service Workeréå¯¾å¿œ', 'error');
                }
            } catch (error) {
                log(`Service Workerã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }

        // Service Workerç™»éŒ²
        async function registerServiceWorker() {
            try {
                const registration = await navigator.serviceWorker.register('/sw.js');
                log('Service Workerç™»éŒ²æˆåŠŸ', 'success');
                
                // Background Syncç™»éŒ²
                if ('sync' in registration) {
                    await registration.sync.register('scheduled-posts-sync');
                    log('Background Syncç™»éŒ²æˆåŠŸ', 'success');
                }
                
                checkServiceWorker();
            } catch (error) {
                log(`Service Workerç™»éŒ²å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // Service Workerå‰Šé™¤
        async function unregisterServiceWorker() {
            try {
                const registrations = await navigator.serviceWorker.getRegistrations();
                for (let registration of registrations) {
                    await registration.unregister();
                }
                log('Service Workerå‰Šé™¤æˆåŠŸ', 'success');
                checkServiceWorker();
            } catch (error) {
                log(`Service Workerå‰Šé™¤å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // IndexedDBç¢ºèª
        async function checkIndexedDB() {
            try {
                const db = await openDB();
                const tx = db.transaction(['scheduled_posts', 'offline_queue'], 'readonly');
                
                const postsStore = tx.objectStore('scheduled_posts');
                const queueStore = tx.objectStore('offline_queue');
                
                const postsCount = await countData(postsStore);
                const queueCount = await countData(queueStore);
                
                const dbDiv = document.getElementById('dbStatus');
                dbDiv.innerHTML = `
                    âœ… IndexedDBæ¥ç¶šæˆåŠŸ<br>
                    ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æŠ•ç¨¿: ${postsCount}ä»¶<br>
                    ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼: ${queueCount}ä»¶
                `;
                
                log(`IndexedDBç¢ºèª: æŠ•ç¨¿${postsCount}ä»¶, ã‚­ãƒ¥ãƒ¼${queueCount}ä»¶`, 'success');
                db.close();
            } catch (error) {
                document.getElementById('dbStatus').textContent = 'âŒ IndexedDBæ¥ç¶šå¤±æ•—';
                log(`IndexedDBã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }

        // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿è¿½åŠ 
        async function addTestData() {
            try {
                const db = await openDB();
                const tx = db.transaction(['scheduled_posts'], 'readwrite');
                const store = tx.objectStore('scheduled_posts');
                
                const testPost = {
                    id: `test-${Date.now()}`,
                    platform: 'x',
                    content: `ãƒ†ã‚¹ãƒˆæŠ•ç¨¿ ${new Date().toLocaleString()}`,
                    status: 'pending',
                    scheduled_for: new Date(Date.now() + 60000).toISOString(), // 1åˆ†å¾Œ
                    metadata: { source: 'test' }
                };
                
                await store.add(testPost);
                log('ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿è¿½åŠ æˆåŠŸ', 'success');
                checkIndexedDB();
                db.close();
            } catch (error) {
                log(`ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿è¿½åŠ å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // IndexedDBã‚¯ãƒªã‚¢
        async function clearIndexedDB() {
            try {
                const db = await openDB();
                const tx = db.transaction(['scheduled_posts', 'offline_queue'], 'readwrite');
                
                await tx.objectStore('scheduled_posts').clear();
                await tx.objectStore('offline_queue').clear();
                
                log('IndexedDBã‚¯ãƒªã‚¢æˆåŠŸ', 'success');
                checkIndexedDB();
                db.close();
            } catch (error) {
                log(`IndexedDBã‚¯ãƒªã‚¢å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        function simulateOffline() {
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                // Service Workerã«ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
                navigator.serviceWorker.controller.postMessage({ type: 'SIMULATE_OFFLINE' });
                log('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ', 'warning');
                
                // UIã‚’æ›´æ–°
                const statusDiv = document.getElementById('networkStatus');
                statusDiv.className = 'status-box offline';
                statusDiv.textContent = 'ğŸŸ¡ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ…‹: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰';
            } else {
                log('Service WorkerãŒåˆ©ç”¨ã§ãã¾ã›ã‚“', 'error');
            }
        }

        // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã«æˆ»ã™
        function simulateOnline() {
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({ type: 'SIMULATE_ONLINE' });
                log('ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã«å¾©å¸°', 'success');
                updateNetworkStatus();
            }
        }

        // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æŠ•ç¨¿ãƒ†ã‚¹ãƒˆ
        async function testOfflinePost() {
            try {
                simulateOffline();
                
                const db = await openDB();
                const tx = db.transaction(['offline_queue'], 'readwrite');
                const store = tx.objectStore('offline_queue');
                
                const testPost = {
                    id: `offline-${Date.now()}`,
                    platform: 'x',
                    content: `ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æŠ•ç¨¿ãƒ†ã‚¹ãƒˆ ${new Date().toLocaleString()}`,
                    status: 'pending',
                    queued_at: new Date().toISOString(),
                    metadata: { source: 'offline-test' }
                };
                
                await store.add(testPost);
                log('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æŠ•ç¨¿ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ', 'success');
                checkOfflineQueue();
                db.close();
            } catch (error) {
                log(`ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æŠ•ç¨¿å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼ç¢ºèª
        async function checkOfflineQueue() {
            try {
                const db = await openDB();
                const tx = db.transaction(['offline_queue'], 'readonly');
                const store = tx.objectStore('offline_queue');
                const items = await store.getAll();
                
                if (items.length > 0) {
                    log(`ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼: ${items.length}ä»¶`, 'info');
                    items.forEach(item => {
                        log(`  - ${item.id}: ${item.content.substring(0, 30)}...`, 'info');
                    });
                } else {
                    log('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼ã¯ç©ºã§ã™', 'info');
                }
                
                db.close();
            } catch (error) {
                log(`ã‚­ãƒ¥ãƒ¼ç¢ºèªå¤±æ•—: ${error.message}`, 'error');
            }
        }

        // ã‚¢ãƒ—ãƒªã‚’é–‹ã
        function openApp() {
            window.open('http://localhost:3000/scheduled-posts', '_blank');
            log('ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹ãã¾ã—ãŸ', 'info');
        }

        // ã‚¢ãƒ—ãƒªçµ±åˆç¢ºèª
        async function checkAppIntegration() {
            try {
                // APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ç¢ºèª
                const response = await fetch('http://localhost:3000/api/scheduled-posts');
                if (response.ok) {
                    const data = await response.json();
                    log(`APIæ¥ç¶šæˆåŠŸ: ${data.posts?.length || 0}ä»¶ã®æŠ•ç¨¿`, 'success');
                } else {
                    log('APIæ¥ç¶šå¤±æ•—', 'error');
                }
                
                // Service WorkerçŠ¶æ…‹
                await checkServiceWorker();
                
                // IndexedDBçŠ¶æ…‹
                await checkIndexedDB();
                
            } catch (error) {
                log(`çµ±åˆç¢ºèªå¤±æ•—: ${error.message}`, 'error');
            }
        }

        // IndexedDB Helper
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('NoteSchedulerDB', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    if (!db.objectStoreNames.contains('scheduled_posts')) {
                        db.createObjectStore('scheduled_posts', { keyPath: 'id' });
                    }
                    
                    if (!db.objectStoreNames.contains('offline_queue')) {
                        db.createObjectStore('offline_queue', { keyPath: 'id' });
                    }
                };
            });
        }

        function countData(store) {
            return new Promise((resolve, reject) => {
                const request = store.count();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
        }

        // åˆæœŸåŒ–
        updateNetworkStatus();
        checkServiceWorker();
        checkIndexedDB();
    </script>
</body>
</html>