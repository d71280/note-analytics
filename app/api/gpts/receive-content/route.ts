import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

// GPTsから生成されたコンテンツを受け取るAPI
interface GPTsContent {
  content: string
  platform: 'x' | 'note' | 'wordpress'
  metadata?: {
    title?: string
    tags?: string[]
    category?: string
    generatedBy?: string
    model?: string
    prompt?: string
  }
  scheduling?: {
    scheduledFor?: string
    timezone?: string
    repeat?: 'none' | 'daily' | 'weekly' | 'monthly'
  }
}

// APIキー認証
function validateApiKey(request: NextRequest): boolean {
  const apiKey = request.headers.get('x-api-key')
  const validApiKey = process.env.GPTS_API_KEY || 'gpts_test_key_2024_note_analytics_x_integration'
  
  // テスト用キーまたは環境変数のキーと一致するか確認
  return apiKey === validApiKey || apiKey === 'gpts_test_key_2024_note_analytics_x_integration'
}

export async function POST(request: NextRequest) {
  console.log('=== GPTs Content Receive API Start ===')
  
  try {
    // API認証
    if (!validateApiKey(request)) {
      return NextResponse.json(
        { error: 'Invalid API key' },
        { status: 401 }
      )
    }
    
    const body: GPTsContent = await request.json()
    const { content, platform, metadata, scheduling } = body
    
    // 必須フィールドの検証
    if (!content || !platform) {
      return NextResponse.json(
        { error: 'Content and platform are required' },
        { status: 400 }
      )
    }
    
    // 文字数制限の検証
    const maxLengths = {
      x: 280,
      note: 3000,
      wordpress: 5000
    }
    
    if (content.length > maxLengths[platform]) {
      return NextResponse.json(
        { 
          error: `Content exceeds maximum length for ${platform}`,
          maxLength: maxLengths[platform],
          currentLength: content.length
        },
        { status: 400 }
      )
    }
    
    const supabase = createClient()
    
    // 受け取ったコンテンツを「スケジュール待ち」状態で保存
    const { data: savedContent, error: saveError } = await supabase
      .from('scheduled_posts')
      .insert({
        content,
        platform,
        scheduled_for: scheduling?.scheduledFor || null, // スケジュール日時が指定されていない場合はnull
        status: scheduling?.scheduledFor ? 'pending' : 'draft', // 日時指定がない場合はdraft
        metadata: {
          ...metadata,
          source: 'gpts',
          generatedBy: metadata?.generatedBy || 'gpts',
          model: metadata?.model || 'unknown',
          prompt: metadata?.prompt,
          receivedAt: new Date().toISOString(),
          needsScheduling: !scheduling?.scheduledFor // スケジューリングが必要かのフラグ
        }
      })
      .select()
      .single()
    
    if (saveError) {
      console.error('Failed to save content:', saveError)
      return NextResponse.json(
        { error: 'Failed to save content', details: saveError.message },
        { status: 500 }
      )
    }
    
    // スケジューリングが指定されている場合、自動的にスケジュール登録
    if (scheduling?.scheduledFor) {
      const { error: scheduleError } = await supabase
        .from('scheduled_posts')
        .insert({
          content,
          platform,
          scheduled_for: scheduling.scheduledFor,
          status: 'pending',
          metadata: {
            ...metadata,
            source: 'gpts',
            contentId: savedContent.id
          }
        })
      
      if (scheduleError) {
        console.error('Failed to schedule content:', scheduleError)
        // スケジューリングに失敗してもコンテンツは保存されているので続行
      }
    }
    
    // 成功レスポンス
    return NextResponse.json({
      success: true,
      contentId: savedContent.id,
      message: 'Content received successfully',
      platform,
      contentLength: content.length,
      scheduled: !!scheduling?.scheduledFor,
      scheduledFor: scheduling?.scheduledFor,
      webUrl: `${process.env.NEXT_PUBLIC_APP_URL}/gpts/contents/${savedContent.id}`
    })
    
  } catch (error) {
    console.error('=== GPTs Content Receive Error ===', error)
    return NextResponse.json(
      { 
        error: 'Failed to process content',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}

// GPTsのActionsスキーマを返すGETエンドポイント
export async function GET() {
  const schema = {
    openapi: '3.0.0',
    info: {
      title: 'Note Analytics Content Receiver',
      version: '1.0.0',
      description: 'Receive and schedule content generated by GPTs'
    },
    servers: [
      {
        url: process.env.NEXT_PUBLIC_APP_URL || 'https://your-app.vercel.app'
      }
    ],
    paths: {
      '/api/gpts/receive-content': {
        post: {
          summary: 'Receive content from GPTs',
          operationId: 'receiveContent',
          security: [
            {
              apiKey: []
            }
          ],
          requestBody: {
            required: true,
            content: {
              'application/json': {
                schema: {
                  type: 'object',
                  required: ['content', 'platform'],
                  properties: {
                    content: {
                      type: 'string',
                      description: 'The generated content text'
                    },
                    platform: {
                      type: 'string',
                      enum: ['x', 'note', 'wordpress'],
                      description: 'Target platform for the content'
                    },
                    metadata: {
                      type: 'object',
                      properties: {
                        title: { type: 'string' },
                        tags: { 
                          type: 'array',
                          items: { type: 'string' }
                        },
                        category: { type: 'string' },
                        generatedBy: { type: 'string' },
                        model: { type: 'string' },
                        prompt: { type: 'string' }
                      }
                    },
                    scheduling: {
                      type: 'object',
                      properties: {
                        scheduledFor: { 
                          type: 'string',
                          format: 'date-time'
                        },
                        timezone: { type: 'string' },
                        repeat: {
                          type: 'string',
                          enum: ['none', 'daily', 'weekly', 'monthly']
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          responses: {
            '200': {
              description: 'Content received successfully',
              content: {
                'application/json': {
                  schema: {
                    type: 'object',
                    properties: {
                      success: { type: 'boolean' },
                      contentId: { type: 'string' },
                      message: { type: 'string' },
                      webUrl: { type: 'string' }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    components: {
      securitySchemes: {
        apiKey: {
          type: 'apiKey',
          in: 'header',
          name: 'x-api-key'
        }
      }
    }
  }
  
  return NextResponse.json(schema)
}